# Writeup of "flagle" challenge from DiceCTF 2022

Writeup author: wiegnand (Lucas Baizer), ashwin.sudhir

The challenge (written by infuzion) had this description:

```
How hard could it be? Just guess the flag.
```

There were no attachments, simply just the link to a website, `https://flagle.mc.ax`.

# Summary

This challenge involves reverse engineering WebAssembly bytecode, as well as obfuscated JavaScript source code, in order to find hard-coded parts of the flag in the code.

# Reversing the JavaScript

The user interface of the website has no usage guide, so I decided to start by reading the JavaScript defined in the [index.html](./index.html) file. Based on how the script used [flag-checker.js](./flag-checker.js), it was clear that the `flag-checker.js` file was autogenerated by Emscripten.

The script uses the Emscripten `cwrap` function to create an entry to the `guess` Wasm function:

```js
const guess = Module.cwrap('guess', 'number', ['number', 'string']);
```

This defines the `guess` variable to be a reference to a function in Wasm, which takes two parameters, a number and a string, and returns a string. Furthermore, based on reading usages of the `guess` function, it became clear how it works (and how the rest of the challenge would play out).

There are 6 pieces of the flag, each of which can be validated using the `guess` function. The first parameter is the flag part, which is `1-6` inclusive (it's not zero-indexed for some reason). The second parameter is a five-character string, i.e. the part we are guessing.

By reading the code we can see:

```js
const result = guess(i, guess_val);
if (result === CORRECT) {
    // CORRECT === 0
    // ...
} else if (result === WRONG_LOCATION) {
    // WRONG_LOCATION === 1
    // ...
} else if (result === INCORRECT) {
    // INCORRECT === 2
    // ...
}
```

`guess` returns three possible statuses, determining if the input passed to is was indeed the correct flag. I decided that the next step was to look into the WebAssembly to see how `guess` works internally.

# Reversing the WebAssembly

The [WebAssembly Binary Toolkit (WABT)](https://github.com/WebAssembly/wabt) has a tool called `wasm-decompile` that can be used to decompile Wasm files into a pseudocode language (somewhat C-esque), which is far more readable than disassembly. I cloned the WABT repository and built the source for it (who likes release builds with prebuilt binaries anyways?), and then used my brand new [wasm-decompile](https://webassembly.github.io/wabt/doc/wasm-decompile.1.html) binary to decompile the [flag-checker.wasm](./flag-checker.wasm) file:

```
wasm-decompile flag-checker.wasm -o flag-checker.wbt
```

I've included the [flag-checker.wbt](./flag-checker.wbt) file in this repository for reference.

We can immediately find some surface-level information in the WBT file:

-   There is a `streq` function, which compares two null-terminated strings.
-   There are several validation functions: `validate`, `validate_1`, `validate_3`, `env_validate_4`, `validate_5`, and `validate_6`.
-   `env_validate_4` is an imported function call which calls out to JavaScript.
-   `guess` somehow calls into the `validate_*` functions.

Now that we have an idea of how the Wasm file is structured, we can begin reverse engineering it.

# Flag Part 1

I began with `validate_1`. It's by far the most simple of all the validation functions:

```js
export function validate_1(a:int):int {
  return streq(a, 1024)
}
```

WebAssembly doesn't directly have pointers (it's weird), so in this case we can sort of interpret the `int` type for the `a` parameter as being more like a `char*` than an `int`. The call to `streq` takes two `char*` parameters, the first being our `a` parameter, and the second being a constant offset in memory, `1024`.

We can look at the top of the WBT file and see how our constant memory is declared:

```js
data d_a(offset: 1024) = "dice{\00";
data d_b(offset: 1030) = "";
```

It seems that `validate_1` just checks that the string is equal to `dice{`. To check if this is right, we can call the `guess` function from our browser's inspector console:

```js
> guess(1, 'dice{') === CORRECT
true
```

Of course this makes sense, as all flags in this CTF start with `dice{`, but now we have a taste for how the rest of the challenge is going to go.

# Flag Part 4

I went straight from Part 1 to Part 4, as I wanted to work with as much JavaScript as I could before diving deep into Wasm, as the JavaScript could contain more human-readable information about the challenge.

Since we know from the WBT file that Part 4 calls out to JavaScript, I searched the Emscripten-generated `flag-checker.js` and found:

```js
function validate_4(a) {
    return c(UTF8ToString(a)) == 0 ? 0 : 1;
}
var asmLibraryArg = {
    validate_4: validate_4,
};
```

This `validate_4` function calls `UTF8ToString(a)` to take the Wasm string "pointer" and convert it to a JavaScript string object. It then calls the function `c()` with that string.

Using my browser's devtools, I was able to find that `c()` was declared in the obfuscated `script.js` file.

The first thing I did with the JavaScript file (after auto-formatting it, of course) was evaluate all the constant numerical expressions like `0x1b3c + -0xc9 * 0x2f + -0x19 * -0x63` in the browser console, with this example yielding the much more simply number, `0`. I then replaced the source code to reflect the simpler values.

Replacing obfuscated function calls back to normal operators was the next step. The obfuscated code has a structure like this:
```js
{
    // ...
    HLPDd: function (g, h) {
        return g === h;
    },
    // ...
}
```
I replaced all calls to `HLPDd()` with the respective `===` operation, and repeated this for all similar operations.

Then, I replaced all indexing operations with their proper properties:
```js
['match'](/.{2}/g) -> match(/.{2}/g)
```
Finally, after replacing base64-encoded data with its original value, using some logical deduction to clear up some math, and refactoring the parameter name, I was able to get this function:
```js
function c(input) {
    let f = current_guess; // current_guess === 4, this is code run by `validate_4`
    try {
        let g =
            intArrayToString(
                window[input](input[f - 1], 'int')() // input[f - 1] === input[3], since current_guess is always 4
                    .toString(16) // number to hex string
                    .match(/.{2}/g) // matches exactly two characters, repeated until the end of the string
                    .map((h) => parseInt(h, 16))
            ) === 'dice'
                ? 1
                : 0;
    } catch {
        return 0;
    }
}
```
Since we know that `input` is always a 5-character string, we need to find all properties of `window` that are 5 characters long, to try and find what `window[input]` is. We also know that `window[input]` is a function that returns another function, which could help deduce what the `input` call is. In my browser console window, I ran:
```js
> Object.keys(window).filter(name => name.length === 5 && typeof window[name] === 'function')
[
    "alert",
    "close",
    "fetch",
    "focus",
    "print",
    "quit_",
    "read_",
    "ccall",
    "cwrap",
    "_free",
    "abort"
]
```
To try and whittle down the possibilities, I recalled the invocation to the function:
```js
window[input](input[f - 1], 'int')()
```
The second parameter being `'int'` makes a good case for the function being either `ccall` or `cwrap`, both Emscripten functions for working with Wasm, as `'int'` is a C/C++ keyword and not a keyword in JavaScript.

Looking at the source code for `cwrap` in `flag-checker.js`, we can see it simply returns a wrapper for `ccall`:
```js
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}
```
I felt pretty certain that Part 4 was `cwrap`, but just to make sure, I wanted to validate it against what the `c()` function does. First, assuming the input is `cwrap` now, I could change:
```js
window[input](input[f - 1], 'int')()
```
to
```js
cwrap('a', 'int')()
```
I then went to the WBT to find the `a()` function:
```js
export function a():int {
  return 1684628325
}
```
`1684628325` as hex is `0x64696365`. We can convert the four-byte value `0x64696365` to a string:
```js
> String.fromCharCode(0x64, 0x69, 0x63, 0x65)
'dice'
```
Recalling the `c()` function, it returned successfully only if the condition was met:
```js
intArrayToString(cwrap('a', 'int')()...) === 'dice'
```
From this, I could reasonably conclude that Part 4 of the flag was `cwrap`.

# Flag Part 3

At this point I began to take a deeper dive into the WBT. I looked at the `validate_3` function:
```js
export function validate_3(a:int, b:int, c:int, d:int, e:int):int {
  var f:int = 0;
  if (b * a != 4800) goto B_a;
  if (c + a != 178) goto B_a;
  if (c + b != 126) goto B_a;
  if (d * c != 9126) goto B_a;
  if (d - e != 62) goto B_a;
  f = c * 4800 - e * d == 367965;
  label B_a:
  return f;
}
```
The `a`, `b`, `c`, `d`, and `e` parameters are the five characters of the input string passed to `guess` respectively. For the first three if statements, I saw it as a system of equations and just plugged the system into [Wolfram Alpha](https://wolframalpha.com) because I'm lazy:
```
> b * a = 4800,  c + a = 178, c + b = 126
a = 100, b = 48, c = 78
```
Now that we have the first three characters, I figured that I could just brute force the last two characters (yes, I'm VERY lazy). The flag alphabet is defined in the `index.html` JavaScript code:
```js
const alphabet = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%&()*+,-./:;<=>?@[]^_{|}~";
```
I turned the alphabet into an array of the ASCII numeric representation of each character:
```js
> const numericAlphabet = Array.from(alphabet).map(ch => ch.charCodeAt(0))
[97, 98, 99, 100, ...]
```
Then I wrote a quick script in the devtools console to brute force the last two values:
```js
const validate_3 = Module.cwrap('validate_3', 'number', ['number', 'number', 'number', 'number', 'number']); // create direct wrapper for validate_3
for (const ch4 of numericAlphabet) {
    for (const ch5 of numericAlphabet) {
        const validateResult = validate_3(100, 48, 78, ch4, ch5); // use our known values + brute force values
        if (validateResult !== 0) {
            console.log(`ch4 = ${ch4}, ch5 = ${ch5}`);
        }
    }
}
```
This resulted in the output `ch4 = 117, ch5 = 55` (and it only took about 3ms). We can now construct a string using our character codes:
```js
> String.fromCharCode(100, 48, 78, 117, 55)
'd0Nu7'
```
From this, we can conclude that Part 3 is `d0Nu7`.

# Flag Part 6

I went to reverse Part 6 next. This is the `validate_6` function from WBT:
```js
export function validate_6(a:int, b:int, c:int, d:int, e:int):int {
  var f:int = 0;
  if ((b + 2933) * (a + 1763) != 5483743) goto B_a;
  f = e == 125 & (d + 1546) * (c + 3913) == 6431119;
  label B_a:
  return f;
}
```
I figured I could brute force the individual parts of this function to find the correct values. I started with `(b + 2933) * (a + 1763) != 5483743`. I wrote some code in the console:
```js
>   for (const a of numericAlphabet) {
        for (const b of numericAlphabet) {
            if ((b + 2933) * (a + 1763) === 5483743) {
                console.log(`a = ${a}, b = ${b}`);
            }
        }
    }

a = 84, b = 36
```
Next I did the same idea for `(d + 1546) * (c + 3913) == 6431119`:
```js
>   for (const c of numericAlphabet) {
        for (const d of numericAlphabet) {
            if ((d + 1546) * (c + 3913) == 6431119) {
                console.log(`c = ${c}, d = ${d}`);
            }
        }
    }

c = 114, d = 51
```
In the WBT, `e` is defined to be the character `125`, no algebra required. We now can construct our 5-letter string:
```js
> String.fromCharCode(84, 36, 114, 51, 125)
'T$r3}'
```
Especially with the last character being a closing curly brace, I was confident that this was the correct Sixth Part of the flag.

# Flag Part 5

I went on to check out `validate_5` next:
```js
export function validate_5(a:int, b:int, c:int, d:int, e:int):int {
  var f:int = g_a - 16;
  f[15]:byte = a;
  f[14]:byte = b;
  f[13]:byte = c;
  f[12]:byte = d;
  f[15]:byte = f[15]:ubyte + 12;
  f[14]:byte = f[14]:ubyte + 4;
  f[13]:byte = f[13]:ubyte + 6;
  f[12]:byte = f[12]:ubyte + 2;
  d = 0;
  if (f[15]:ubyte != 121) goto B_a;
  if (f[14]:ubyte != 68) goto B_a;
  if (f[13]:ubyte != 126) goto B_a;
  d = e == 77 & f[12]:ubyte == 35;
  label B_a:
  return d;
}
```
This function is quite easy to reverse. You can see that `a`, `b`, `c`, and `d` get assigned to memory in the buffer called `f`. Each character has an arbitrary value added to it, and then its value is checked in an if statement. For example, focusing on just the letter `a`:
```js
f[15]:byte = a;
f[15]:byte = f[15]:ubyte + 12;
f[15]:ubyte == 121
```
By simply taking `121 - 12`, we can find that the character code for `a` should be `109`. We can follow this logic for the rest of the values in the function, except for `e`, whose value is clearly defined to be `77`.

We now can construct our 5-letter string:
```js
> String.fromCharCode(121 - 12, 68 - 4, 126 - 6, 35 - 2, 77)
'm@x!M'
```

# Flag Part 2
(Solved by ashwin.sudhir)

In this part the user input is shuffled around a but which makes it a little harder to follow but is easy to solve using the browser debugger, since we can directly set breakpoints in the WebAssembly and see what our input is being compared to at the end.
Just make sure that all the characters in the input are unique so you can keep a track of the location of the of the characters.

The second part of the flag is actually evaluated inside of the `guess` function:
```js
export function guess(a:int, b:int):int {
  var c:int = g_a - 16;
  g_a = c;
  var d:int = 2;
  if (f_k(b) != 5) goto B_a;
  if (eqz(streq(b, 1024))) goto B_b;
  d = a != 1;
  goto B_a;
  label B_b:
  var e:int = b[4]:ubyte;
  d = b[3]:ubyte;
  var f:int = b[2]:ubyte;
  var g:int = b[1]:ubyte;
  c[11]:byte = b[0]:ubyte;
  c[10]:byte = g;
  c[9]:byte = f;
  c[8]:byte = d;
  d = c[10]:ubyte;
  c[10]:byte = c[9]:ubyte;
  c[9]:byte = d;
  d = c[9]:ubyte;
  c[9]:byte = c[8]:ubyte;
  c[8]:byte = d;
  d = c[9]:ubyte;
  c[9]:byte = c[11]:ubyte;
  c[11]:byte = d;
  d = c[9]:ubyte;
  c[9]:byte = c[8]:ubyte;
  c[8]:byte = d;
  d = c[11]:ubyte;
  c[11]:byte = c[10]:ubyte;
  c[10]:byte = d;
  if (c[11]:ubyte != 51) goto B_c;
  if (c[10]:ubyte != 108) goto B_c;
  if (c[9]:ubyte != 33) goto B_c;
  d = c[8]:ubyte;
  if ((e & 255) != 68) goto B_c;
  if ((d & 255) != 70) goto B_c;
  ...
}
```
You can see the `if` statements at the end of this function snippet. After following through what the values are, we can determine:
```
a = 70
b = 33
c = 51
d = 108
e = 68
```
Evaluating the string:
```js
> String.fromCharCode(70, 33, 51, 108, 68)
'F!3lD'
```
We now know that Part 2 is `F!3lD`.

# Wrapping Up

Now that I figured out all the parts for the flag, I made sure the `guess` function agreed with all my findings:
```js
>   current_guess = 1;
    console.log(guess(1, 'dice{') === CORRECT);
    current_guess = 2;
    console.log(guess(2, 'F!3lD') === CORRECT);
    current_guess = 3;
    console.log(guess(3, 'd0Nu7') === CORRECT);
    current_guess = 4;
    console.log(guess(4, 'cwrap') === CORRECT);
    current_guess = 5;
    console.log(guess(5, 'm@x!M') === CORRECT);
    current_guess = 6;
    console.log(guess(6, 'T$r3}') === CORRECT);

true
true
true
true
true
true
```

As all the pieces appeared to be correct, I submitted the final flag: `dice{F!3lDd0Nu7cwrapm@x!MT$r3}`.
